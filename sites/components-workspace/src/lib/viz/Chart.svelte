<script>
    // ---------------------------------------------------------------------------------------
    // Imports
    // ---------------------------------------------------------------------------------------
        import { props, config } from '$lib/modules/stores.js';   

        import ECharts from "./ECharts.svelte";
        import getColumnSummary from '$lib/modules/getColumnSummary';
        import getDistinctValues from '$lib/modules/getDistinctValues';
        import formatAxisLabel from '$lib/modules/formatAxisLabel';
        import formatTitle from '$lib/modules/formatTitle.js';
        import ErrorChart from './ErrorChart.svelte';
        import checkInputs from '$lib/modules/checkInputs';

    // ---------------------------------------------------------------------------------------
    // Input Props
    // ---------------------------------------------------------------------------------------
        // Data and columns:
        export let data = undefined;
        export let x = undefined;
        export let y = undefined;
        export let series = undefined;
        export let size = undefined;

        export let horiz = false; // Flipped axis chart
        if(horiz === "true" || horiz === true){
            horiz = true;
        } else {
            horiz = false;
        }

        // Chart titles:
        export let title = undefined;
        export let subtitle = undefined;

        // Chart type:
        export let chartType = "Chart"; // Used to label chart error messages
        export let bubble = false;
        export let hist = false;
        let reqCols;

        // X axis:
        export let xType = undefined; // category or value
        export let xAxisTitle = 'false'; // Default false. If true, use formatTitle(x). Or you can supply a custom string
        export let xBaseline = true;
        xBaseline = (xBaseline === "true" || xBaseline === true);
        export let xTickMarks = false;
        xTickMarks = (xTickMarks === "true" || xTickMarks === true);
        export let xGridlines = false;
        xGridlines = (xGridlines === "true" || xGridlines === true);
        export let xAxisLabels = true;
        xAxisLabels = (xAxisLabels === "true" || xAxisLabels === true);
        export let sort = true; // sorts x values in case x is out of order in dataset (e.g., would create line chart that is out of order)
        sort = (sort === "true" || sort === true);

        // Y axis:
        export let yAxisTitle = 'false'; // Default false. If true, use formatTitle(x). Or you can supply a custom string
        export let yBaseline = false;
        yBaseline = (yBaseline === "true" || yBaseline === true);
        export let yTickMarks = false;
        yTickMarks = (yTickMarks === "true" || yTickMarks === true);
        export let yGridlines = true;
        yGridlines = (yGridlines === "true" || yGridlines === true);
        export let yAxisLabels = true;
        yAxisLabels = (yAxisLabels === "true" || yAxisLabels === true);
        export let yMin = undefined;

        // Legend:
        export let legend = true;
        legend = (legend === "true" || legend === true);

        // Additional Config Options:
        export let options = undefined; // additional ECharts config object that will append to the config generated by our API

    // ---------------------------------------------------------------------------------------
    // Variable Declaration
    // ---------------------------------------------------------------------------------------
        // Column Summary:
        let columnSummary;
        let columnNames;
        let uColNames = [];
        let unusedColumns = [];
        let uColType;
        let uColName;
        let xDataType;
        let xMismatch;
        let xFormat;
        let yFormat;
        let xUnits;
        let yUnits;       
        let xDistinct;

        // Individual Config Sections:
        let horizAxisConfig;
        let verticalAxisConfig;
        let horizAxisTitleConfig;      
        let chartConfig;
  
        // Chart area sizing:
        let chartAreaHeight;
        let hasTitle;
        let hasSubtitle;
        let hasLegend;
        let hasTopAxisTitle;
        let hasBottomAxisTitle;
        let titleFontSize;
        let subtitleFontSize;
        let titleBoxPadding;
        let titleBoxHeight;
        let chartAreaPaddingTop;
        let chartAreaPaddingBottom;
        let bottomAxisTitleSize;
        let topAxisTitleSize; 
        let legendHeight;
        let legendPaddingTop;
        let legendTop;
        let chartTop;
        let chartBottom;
        let chartContainerHeight;
        let topAxisTitleTop;

        let horizAxisTitle;

        // Adjustment to avoid small bars on horizontal bar chart (extend chart height to accomodate):
        let maxBars;
        let barCount;
        let heightMultiplier;

        // Set final chart height:
        let height;
        let width;


        let missingCols = [];

        // Error Handling:

        let inputCols = [];
        let optCols = [];
        let i;

let error;
try{
    checkInputs(data); // check that dataset exists

    // ---------------------------------------------------------------------------------------
    // Get column information
    // ---------------------------------------------------------------------------------------
        // Get column summary:
        columnSummary = getColumnSummary(data);

        // Get column names:
        columnNames = Object.keys(columnSummary)

    // ---------------------------------------------------------------------------------------
    // Make assumptions to complete required props
    // ---------------------------------------------------------------------------------------
        // If no x column supplied, assume first column in dataset is x:
        if(!x){
            x = columnNames[0]
        }

        // If no y column(s) supplied, assume all columns other than x are the y columns:
        uColNames = columnNames.filter(function(col){
            return ![x, series, size].includes(col)
        });

        for(let i = 0; i < uColNames.length; i++){
            uColName = uColNames[i]
            uColType = columnSummary[uColName].type
            if(uColType === "number"){
                unusedColumns.push(uColName)
            }
        }

        if(!y){
            y = unusedColumns.length > 1 ? unusedColumns : unusedColumns[0];
        }

        // Establish required columns based on chart type:
        if(bubble){
            reqCols = {
                "x": x,
                "y": y,
                "size": size
            }
        } else if(hist){
            reqCols = {
                "x": x
            }
        } else {
            reqCols = {
                "x": x,
                "y": y
            }
        }

        // Check which columns were not supplied to the chart:
        for(let property in reqCols){
            if(reqCols[property] == null){
                missingCols.push(property)
            }
        }
        
        if(missingCols.length === 1) { 
            throw Error(new Intl.ListFormat().format(missingCols) + " is required");
        } else if(missingCols.length > 1){
            throw Error(new Intl.ListFormat().format(missingCols) + " are required");
        }

        // Check the inputs supplied to the chart:
        if(x){inputCols.push(x)};
        if(y){
            if(typeof y === 'object'){
                for(i=0; i < y.length; i++){
                    inputCols.push(y[i])
                }
            } else {
                inputCols.push(y)
            }
        };
        if(size){inputCols.push(size)};
        if(series){optCols.push(series)};

        checkInputs(data, inputCols, optCols)

    // ---------------------------------------------------------------------------------------
    // Define x axis type
    // ---------------------------------------------------------------------------------------
        xDataType = columnSummary[x].type;

        // Get xDataType into ECharts default types:
        switch (xDataType) {
            case "number":
                xDataType = "value";
                break;
            case "string":
                xDataType = "category";
                break;
            case "date":
                xDataType = "time";
                break;
            default:
                break;
        }

        xType = xType ?? xDataType;

        // Check for x mismatch:
        xMismatch = (xDataType === "value" && xType === "category");

    // ---------------------------------------------------------------------------------------
    // Sort data by x
    // ---------------------------------------------------------------------------------------
        function getSortedData(data, prop, isAsc) {
            return data.sort((a, b) => {
                return (a[prop] < b[prop] ? -1 : 1) * (isAsc ? 1 : -1)
            });
        }

        data = sort ? getSortedData(data, x, true) : data;

    // ---------------------------------------------------------------------------------------
    // Get format codes for axes
    // ---------------------------------------------------------------------------------------
        xFormat = columnSummary[x].format;
        if(!y){yFormat = "str"} else {
            if(typeof y === 'object'){
                yFormat = columnSummary[y[0]].format;
            } else {
                yFormat = columnSummary[y].format;
            }
        }

        xUnits = columnSummary[x].units;
        
        if(!y){yUnits = ''} else {
            if(typeof y === 'object'){
                yUnits = columnSummary[y[0]].units;
            } else {
                yUnits = columnSummary[y].units;
            }
        }

        xAxisTitle = xAxisTitle === 'true' ? formatTitle(x, xFormat) : xAxisTitle === 'false' ? '' : xAxisTitle;
        yAxisTitle = yAxisTitle === 'true' ? formatTitle(y, yFormat) : yAxisTitle === 'false' ? '' : yAxisTitle;

    // ---------------------------------------------------------------------------------------
    // Add props to store to let child components access them
    // ---------------------------------------------------------------------------------------
        props.update(d => {return {...d, data, x, y, series, horiz, xMismatch, size, yMin, columnSummary}});

    // ---------------------------------------------------------------------------------------
    // Axis Configuration
    // ---------------------------------------------------------------------------------------
        xDistinct = getDistinctValues(data, x);

        if(horiz){
            horizAxisConfig = {
                type: "value",
                position: "top",
                axisLabel: {
                    show: yAxisLabels,
                    hideOverlap: true,
                    showMaxLabel: true,
                    formatter: function(value){
                            return formatAxisLabel(value, yFormat, yUnits)
                    },
                    margin: 4
                },
                min: yMin,
                splitLine: {
                    show: yGridlines
                },
                axisLine: {
                    show: yBaseline,
                    onZero: false
                },
                axisTick: {
                    show: yTickMarks
                },
                boundaryGap: false
            }
        } else {
            horizAxisConfig = {
                    type: xType,
                    data: xDistinct,
                    splitLine: {
                        show: xGridlines
                    },
                    axisLine: {
                        show: xBaseline
                    },
                    axisTick: {
                        show: xTickMarks
                    },
                    axisLabel: {
                        show: xAxisLabels,
                        hideOverlap: true,
                        showMaxLabel: (xType === "category"),
                        formatter: 
                            xType === 'time' ? false :                         
                            function(value){
                                return formatAxisLabel(value, xFormat, xUnits)
                            },
                        margin: 6
                    },
                    scale: true,
                    // splitNumber: 8,
                    // boundaryGap: xType === "category" ? true : ['1%', '1%'],
                    // min: columnSummary[x].extents[0]
            } 
        } 


        if(horiz){
            verticalAxisConfig = {
                type: xType, 
                data: xDistinct, 
                inverse: "true",
                splitLine: {
                    show: xGridlines
                },
                axisLine: {
                    show: xBaseline
                },
                axisTick: {
                    show: xTickMarks
                },
                axisLabel: {
                    show: xAxisLabels,
                    hideOverlap: true,
                    formatter: function(value){
                            return formatAxisLabel(value, xFormat, xUnits)
                    }
                },
                scale: true
            }
        } else {
            verticalAxisConfig = {
                    type: "value",
                    splitLine: {
                        show: yGridlines
                    },
                    axisLine: {
                        show: yBaseline,
                        onZero: false
                    },
                    axisTick: {
                        show: yTickMarks
                    },
                    axisLabel: {
                        show: yAxisLabels,
                        hideOverlap: true,
                        margin: 4,
                        formatter: function(value){
                            return formatAxisLabel(value, yFormat, yUnits)
                        }
                    },
                    name: yAxisTitle,
                    nameLocation: 'end',
                    nameTextStyle: {
                        align: 'left',
                        verticalAlign: 'top',
                        backgroundColor: 'white',
                        padding: [0,5,0,0]
                    },
                    nameGap: 6,
                    min: yMin,
                    boundaryGap: ['0%', '1%'],
                }
        }

    // ---------------------------------------------------------------------------------------
    // Set up chart area
    // ---------------------------------------------------------------------------------------
        chartAreaHeight = 180; // standard height for chart area across all charts

        hasTitle = title ? true : false;
        hasSubtitle = subtitle ? true: false;
        hasLegend = legend * (series !== null || (typeof y === 'object' && y.length > 1));
        hasTopAxisTitle = yAxisTitle !== '' && horiz;
        hasBottomAxisTitle = xAxisTitle !== '' && !horiz;

        titleFontSize = 15;
        subtitleFontSize = 13;
        titleBoxPadding = 6 * (hasSubtitle);

        titleBoxHeight = (hasTitle * titleFontSize) + (hasSubtitle * subtitleFontSize) + (titleBoxPadding * Math.max(hasTitle, hasSubtitle));

        chartAreaPaddingTop = 10;
        chartAreaPaddingBottom = 8;

        bottomAxisTitleSize = 14;
        topAxisTitleSize = 14 + 0; // font size + padding top

        legendHeight = 15;
        legendHeight = legendHeight * hasLegend;

        legendPaddingTop = 10;
        legendPaddingTop = legendPaddingTop * Math.max(hasTitle, hasSubtitle);

        legendTop = titleBoxHeight + legendPaddingTop;
        chartTop = legendTop + legendHeight + (topAxisTitleSize * hasTopAxisTitle) + chartAreaPaddingTop;
        chartBottom = (hasBottomAxisTitle * bottomAxisTitleSize) + chartAreaPaddingBottom;
        chartContainerHeight = chartAreaHeight + chartTop + chartBottom;

        topAxisTitleTop = legendTop + legendHeight + 7;

        // Adjustment to avoid small bars on horizontal bar chart (extend chart height to accomodate)
        // Small bars are allowed on normal bar chart (e.g., time series bar chart)
        maxBars = 6;
        heightMultiplier = 1;
        if(horiz){
            barCount = xDistinct.length;
            heightMultiplier = Math.max(1, barCount / maxBars);
        }

        // Set final chart height:
        height = (chartContainerHeight * heightMultiplier) + 'px';
        width = '100%';

    // ---------------------------------------------------------------------------------------
    // Set up horizontal axis title (custom graphic)
    // ---------------------------------------------------------------------------------------
        horizAxisTitle = horiz ? yAxisTitle : xAxisTitle;
        if(horizAxisTitle !== ''){
            horizAxisTitle = horizAxisTitle + " \u2192"  // u2192 is js escaped version of &rarr;
        }
        
        horizAxisTitleConfig = {
                id: 'horiz-axis-title',
                type: 'text',
                style: {
                    text: horizAxisTitle,
                    textAlign: 'right',
                    fill: '#6E7079',
                },
                cursor: 'auto',
                // Positioning (if horiz, top right; otherwise bottom right)
                right: horiz ? '2%' : '1%',
                top: horiz ? topAxisTitleTop : null,
                bottom: horiz ? null: '2%'
            };

    // ---------------------------------------------------------------------------------------
    // Build chart config and update config store so child components can access it
    // ---------------------------------------------------------------------------------------
        chartConfig = {
            title: {
                text: title,
                subtext: subtitle,
                subtextStyle: {
                    width: width
                },
            },
            tooltip: {
                trigger: "item",
                axisPointer: {
                    // Use axis to trigger tooltip
                    type: "shadow", // 'shadow' as default; can also be 'line' or 'shadow'
                },
                padding: 6,
                borderRadius: 4, 
                borderWidth: 1,
                borderColor: '#c4c4c4',
                backgroundColor: '#f0f0f0',
                textStyle: {
                    color: '#3d3d3d',
                    fontSize: 12
                }
            },
            legend: {
                show: legend,
                type: "scroll",
                top: legendTop,
                padding: [0, 0, 0, 0]
            },       
            grid: {
                left: "0.5%",
                right: horiz ? "4%" : "0%",
                bottom: chartBottom,
                top: chartTop,
                containLabel: true,
            },
            xAxis: horizAxisConfig,
            yAxis: verticalAxisConfig,
            series: [],
            animation: false,
            graphic: horizAxisTitleConfig,
            // toolbox: {
            //     show: true,
            //     feature: {
            //         dataView: {
            //             show: true
            //         }
            //     }
            // }
        };

        if(options){
            chartConfig = {...chartConfig, ...options}
        }

        config.update(d => { return chartConfig });

} catch(e) {
    error = e.message;
    props.update(d => { return {...d, error} })
}
console.log()
</script>


{#if !error}

<slot></slot>
<ECharts config={$config} {height} {width}/>

{:else}

<ErrorChart {error} {chartType}/>

{/if}

